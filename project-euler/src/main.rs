fn main() {
    let answer_1 = euler_1();
    println!("{}", answer_1);

    let answer_2 = euler_2();
    println!("{}", answer_2);

    let answer_3 = euler_3();
    println!("{}", answer_3);

    let answer_7 = euler_7();
    println!("{}", answer_7);

    let answer_35 = euler_35();
    println!("{}", answer_35);
}

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
// Answer 233168
fn euler_1() -> i32 {
    let mut sum = 0;

    for i in 1..1000 {
        if i % 3 == 0 {
            sum += i;
        }
        else if i % 5 == 0 {
            sum += i;
        }
    }

    sum
}

// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
// Answer 4613732
fn euler_2() -> i32 {
    let mut v = vec![1,2];

    let mut sum: i32 = v.iter().rev().take(2).sum();
    while sum < 4000000 {
        v.push(sum);
        sum = v.iter().rev().take(2).sum();
    }

    let answer: i32 = v.into_iter().filter(|x| x % 2 == 0).sum();
    answer
}


// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?
// Answer 6857
// NB this is not fast enough to check the real key space should look into profiling
fn euler_3() -> i64 {
    let upper: i64 = 600851475143 / 10000;

    for i in (2..upper).rev() {

        if 600851475143 % i == 0 {
            let mut is_prime = true;

            for j in 2..i {
                if i % j == 0 {
                    is_prime = false;
                }
            }

            if is_prime {
                if 600851475143 % i == 0 {
                    return i
                }
            }
        }
    }

    0
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number?
// Answer 104743
fn euler_7() -> i32 {
    
    let mut count = 0;
    let mut i = 2;

    loop {
        let mut is_prime = true;

        for j in 2..i {
            if i % j == 0 {
                is_prime = false;
            }
        }

        if is_prime {
            count += 1;
        }

        if count == 10001 {
            break;
        }

        i += 1;
    }

    i
}

// The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
// There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
// How many circular primes are there below one million?
fn euler_35() -> i32 {
    let mut count = 0;

    for i in 1..1000000 {
        if !is_excluded(i) && is_prime(i) {
            let mut rot = rotate_number(i);
            let mut is_circular = true;

            for _ in 1..i.to_string().len() {
                if !is_prime(rot) {
                    is_circular = false;
                    break;
                }
                rot = rotate_number(rot);
            }

            if is_circular {
                // println!("{}", i);
                count += 1;
            }
        }
    }

    count
}

fn is_excluded(x: i32) -> bool {
    if x == 2 {
        return false;
    }

    if contains_digit(x, 2) || contains_digit(x, 4) || contains_digit(x, 5) || contains_digit(x, 6) || contains_digit(x, 8) || contains_digit(x, 0) {
        return true;
    }

    false
}


fn is_prime(x: i32) -> bool {
    if x == 2 {
        return true;
    }
    if x == 3 {
        return true;
    }
    if x % 2 == 0 {
        return false;
    }
    if x % 3 == 0 {
        return false;
    }

    let mut i = 5;
    let mut w = 2;

    while i * i <= x {
        if x % i == 0 {
            return false;
        }

        i += w;
        w = 6 - w;
    }

    true
}

fn contains_digit(haystack: i32, needle: i32) -> bool {
    let mut this_number = haystack;
    let mut this_digit;

    while this_number != 0 {
        this_digit = this_number % 10;
        this_number = this_number / 10;

        if this_digit == needle {
            return true;
        }
    }

    return false;
}

fn rotate_number(x: i32) -> i32 {
    if x >= 1000000000 {
        return (x - ( (x / 1000000000) * 1000000000)) * 10 + (x / 1000000000);
    }
    if x >= 100000000 {
        return (x - ( (x / 100000000) * 100000000)) * 10 + (x / 100000000);
    }
    if x >= 10000000 {
        return (x - ( (x / 10000000) * 10000000)) * 10 + (x / 10000000);
    }
    if x >= 1000000 {
        return (x - ( (x / 1000000) * 1000000)) * 10 + (x / 1000000);
    }
    if x >= 100000 {
        return (x - ( (x / 100000) * 100000)) * 10 + (x / 100000);
    }
    if x >= 10000 {
        return (x - ( (x / 10000) * 10000)) * 10 + (x / 10000);
    }
    if x >= 1000 {
        return (x - ( (x / 1000) * 1000)) * 10 + (x / 1000);
    }
    if x >= 100 {
        return (x - ( (x / 100) * 100)) * 10 + (x / 100);
    }
    if x >= 10 {
        return (x - ( (x / 10) * 10)) * 10 + (x / 10);
    }

    x
}

#[cfg(test)]
mod main {
    use super::*;

    #[test]
    fn test_euler_1() {
         assert_eq!(233168, euler_1());
    }

    #[test]
    fn test_euler_2() {
         assert_eq!(4613732, euler_2());
    }

    #[test]
    fn test_euler_3() {
         assert_eq!(6857, euler_3());
    }

    #[test]
    fn test_euler_7() {
         assert_eq!(104743, euler_7());
    }

    #[test]
    fn test_euler_35() {
         assert_eq!(55, euler_35());
    }

    #[test]
    fn test_rotate_number() {
        assert_eq!(1, rotate_number(1));
        assert_eq!(2, rotate_number(2));
        assert_eq!(199, rotate_number(919));
        assert_eq!(919, rotate_number(991));
        assert_eq!(999, rotate_number(999));
        assert_eq!(112, rotate_number(211));
        assert_eq!(9991, rotate_number(1999));
        assert_eq!(9919, rotate_number(9991));
    }
}


